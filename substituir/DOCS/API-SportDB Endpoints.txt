Endpoints que vão te atender
Da documentação da SportDB.dev:
​

Ao vivo

GET /api/football/live

GET /api/basketball/live

GET /api/hockey/live

Países / competições / fixtures

GET /api/{sport}/countries

GET /api/{sport}/{country_slug} → inclui lista de competições.

GET /api/{sport}/{country_slug}/{competition_slug}/{season}/fixtures → fixtures da temporada (você filtra por dia/semana no código).

Match + estatísticas

GET /api/match/:match_id

GET /api/match/:match_id/lineups

GET /api/match/:match_id/stats

Com isso você consegue: jogos do dia, da semana (filtrando por data nos fixtures), jogos ao vivo e stats dos jogos ao vivo em futebol, basquete e hóquei; ténis vem como multi-sport, mas usa a mesma estrutura de fixtures/matches.
​

SQL de base para Supabase
sql
create table if not exists competitions (
  id bigint generated by default as identity primary key,
  sport text not null,
  country_slug text not null,
  competition_slug text not null,
  name text,
  season text,
  unique (sport, country_slug, competition_slug, season)
);

create table if not exists matches (
  id bigint primary key,
  competition_id bigint references competitions(id),
  sport text not null,
  status text,
  start_time timestamptz,
  home_team text,
  away_team text,
  home_score int,
  away_score int,
  is_live boolean default false,
  raw jsonb,
  updated_at timestamptz default now()
);

create table if not exists match_stats (
  match_id bigint primary key references matches(id) on delete cascade,
  stats jsonb,
  updated_at timestamptz default now()
);
Módulo Python completo (coleta contínua + Supabase)
python
import os
import time
import datetime as dt
from typing import List, Dict, Any, Optional, Tuple

import requests
from supabase import create_client, Client

# ==========================
# Config
# ==========================

SPORTDB_BASE_URL = "https://sportdb.dev"
SPORTDB_API_KEY = os.environ.get("SPORTDB_API_KEY")

SUPABASE_URL = os.environ.get("SUPABASE_URL")
SUPABASE_KEY = os.environ.get("SUPABASE_KEY")

# quais esportes quer monitorar
SPORTS = ["football", "basketball", "tennis"]  # adicione "hockey" se quiser

LIVE_POLL_INTERVAL = 30          # segundos
FIXTURES_POLL_INTERVAL = 60 * 10 # 10 minutos

supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)


# ==========================
# HTTP helper
# ==========================

def sportdb_get(path: str, params: Optional[Dict[str, Any]] = None) -> Any:
    headers = {}
    if SPORTDB_API_KEY:
        headers["Authorization"] = f"Bearer {SPORTDB_API_KEY}"
    url = f"{SPORTDB_BASE_URL}{path}"
    r = requests.get(url, headers=headers, params=params, timeout=10)
    r.raise_for_status()
    return r.json()


# ==========================
# Endpoints SportDB
# ==========================

def get_countries(sport: str) -> List[Dict[str, Any]]:
    data = sportdb_get(f"/api/{sport}/countries")
    return data.get("countries", data)


def get_country_detail(sport: str, country_slug: str) -> Dict[str, Any]:
    return sportdb_get(f"/api/{sport}/{country_slug}")


def get_competitions_from_country_payload(payload: Dict[str, Any]) -> List[Dict[str, Any]]:
    # doc diz que a resposta inclui competições; o campo costuma se chamar "competitions"
    return payload.get("competitions", [])


def get_fixtures(sport: str, country_slug: str, competition_slug: str, season: str) -> List[Dict[str, Any]]:
    path = f"/api/{sport}/{country_slug}/{competition_slug}/{season}/fixtures"
    data = sportdb_get(path)
    return data.get("matches", data)


def get_live_matches(sport: str) -> List[Dict[str, Any]]:
    data = sportdb_get(f"/api/{sport}/live")
    return data.get("matches", data)


def get_match_stats(match_id: int) -> Dict[str, Any]:
    return sportdb_get(f"/api/match/{match_id}/stats")


# ==========================
# Supabase helpers
# ==========================

def upsert_competition(
    sport: str,
    country_slug: str,
    comp: Dict[str, Any],
    season: str
) -> int:
    # tenta pegar id se a API fornece; se não, deixa nulo e usa unique(sport, country_slug, competition_slug, season)
    comp_slug = comp.get("slug") or comp.get("competition_slug")
    name = comp.get("name") or comp_slug

    resp = supabase.table("competitions").upsert({
        "sport": sport,
        "country_slug": country_slug,
        "competition_slug": comp_slug,
        "name": name,
        "season": season,
    }).select("id").execute()

    if resp.data:
        return resp.data[0]["id"]
    # fallback: busca pela combinação única
    resp2 = supabase.table("competitions").select("id").eq("sport", sport)\
        .eq("country_slug", country_slug)\
        .eq("competition_slug", comp_slug)\
        .eq("season", season).single().execute()
    return resp2.data["id"]


def upsert_match(
    sport: str,
    competition_id: Optional[int],
    payload: Dict[str, Any],
    is_live: bool
) -> None:
    # mapeia campos comuns; ajuste se o payload real tiver nomes diferentes
    match_id = payload["id"]

    start_time = payload.get("start_time") or payload.get("kickoff_time")
    home_team = payload.get("home_team") or payload.get("home", {}).get("name")
    away_team = payload.get("away_team") or payload.get("away", {}).get("name")
    home_score = payload.get("home_score") or payload.get("home", {}).get("score")
    away_score = payload.get("away_score") or payload.get("away", {}).get("score")

    row = {
        "id": match_id,
        "competition_id": competition_id,
        "sport": sport,
        "status": payload.get("status"),
        "start_time": start_time,
        "home_team": home_team,
        "away_team": away_team,
        "home_score": home_score,
        "away_score": away_score,
        "is_live": is_live,
        "raw": payload,
        "updated_at": dt.datetime.utcnow().isoformat(),
    }
    supabase.table("matches").upsert(row).execute()


def upsert_match_stats_row(match_id: int, stats: Dict[str, Any]) -> None:
    row = {
        "match_id": match_id,
        "stats": stats,
        "updated_at": dt.datetime.utcnow().isoformat(),
    }
    supabase.table("match_stats").upsert(row).execute()


# ==========================
# Filtros por data
# ==========================

def parse_match_date(payload: Dict[str, Any]) -> Optional[dt.date]:
    start_time = payload.get("start_time") or payload.get("kickoff_time")
    if not start_time:
        return None
    try:
        # assume ISO8601
        d = dt.datetime.fromisoformat(start_time.replace("Z", "+00:00")).date()
        return d
    except Exception:
        return None


def filter_matches_by_date_range(
    matches: List[Dict[str, Any]],
    start: dt.date,
    end: dt.date
) -> List[Dict[str, Any]]:
    result = []
    for m in matches:
        d = parse_match_date(m)
        if not d:
            continue
        if start <= d <= end:
            result.append(m)
    return result


def get_week_range() -> Tuple[dt.date, dt.date]:
    today = dt.date.today()
    # hoje até hoje + 7 → "domingo a domingo" flexível
    return today, today + dt.timedelta(days=7)


# ==========================
# Sincronizações
# ==========================

def sync_fixtures_for_week() -> None:
    start, end = get_week_range()

    for sport in SPORTS:
        countries = get_countries(sport)
        for country in countries:
            country_slug = country.get("slug") or country.get("code") or country.get("id")
            if not country_slug:
                continue

            country_payload = get_country_detail(sport, country_slug)
            competitions = get_competitions_from_country_payload(country_payload)

            # a resposta de competition inclui seasons; pega apenas season atual se existir
            for comp in competitions:
                seasons = comp.get("seasons") or []
                if not seasons:
                    continue

                # tenta achar a season marcada como current, senão pega a última
                current = next((s for s in seasons if s.get("current")), seasons[-1])
                season_name = current.get("name") or current.get("season") or str(current.get("id"))

                comp_db_id = upsert_competition(sport, country_slug, comp, season_name)

                fixtures = get_fixtures(sport, country_slug, comp.get("slug"), season_name)
                week_matches = filter_matches_by_date_range(fixtures, start, end)

                for m in week_matches:
                    upsert_match(sport, comp_db_id, m, is_live=False)


def sync_matches_for_day(target_date: Optional[dt.date] = None) -> None:
    if not target_date:
        target_date = dt.date.today()

    for sport in SPORTS:
        countries = get_countries(sport)
        for country in countries:
            country_slug = country.get("slug") or country.get("code") or country.get("id")
            if not country_slug:
                continue

            country_payload = get_country_detail(sport, country_slug)
            competitions = get_competitions_from_country_payload(country_payload)

            for comp in competitions:
                seasons = comp.get("seasons") or []
                if not seasons:
                    continue

                current = next((s for s in seasons if s.get("current")), seasons[-1])
                season_name = current.get("name") or current.get("season") or str(current.get("id"))

                comp_db_id = upsert_competition(sport, country_slug, comp, season_name)

                fixtures = get_fixtures(sport, country_slug, comp.get("slug"), season_name)
                day_matches = filter_matches_by_date_range(fixtures, target_date, target_date)

                for m in day_matches:
                    upsert_match(sport, comp_db_id, m, is_live=False)


def sync_live_matches_and_stats() -> None:
    for sport in SPORTS:
        live_matches = get_live_matches(sport)
        for m in live_matches:
            match_id = m["id"]
            # competition_id pode vir no payload; se não vier, deixa None
            competition_id = m.get("competition_id")
            upsert_match(sport, competition_id, m, is_live=True)

            try:
                stats = get_match_stats(match_id)
                upsert_match_stats_row(match_id, stats)
            except Exception as e:
                print(f"[WARN] stats erro match {match_id}: {e}")


# ==========================
# Loop principal
# ==========================

def main_loop():
    last_fixtures_sync = 0.0
    last_day_sync = 0.0

    while True:
        now = time.time()

        if now - last_fixtures_sync > FIXTURES_POLL_INTERVAL:
            try:
                sync_fixtures_for_week()
            except Exception as e:
                print("[ERROR] sync_fixtures_for_week:", e)
            last_fixtures_sync = now

        if now - last_day_sync > FIXTURES_POLL_INTERVAL:
            try:
                sync_matches_for_day()
            except Exception as e:
                print("[ERROR] sync_matches_for_day:", e)
            last_day_sync = now

        try:
            sync_live_matches_and_stats()
        except Exception as e:
            print("[ERROR] sync_live_matches_and_stats:", e)

        time.sleep(LIVE_POLL_INTERVAL)


if __name__ == "__main__":
    main_loop()
Onde ajustar rápido
Se no API Explorer os campos tiverem nomes diferentes (ex.: kickoff_at, home.name), ajusta só a função upsert_match.
​